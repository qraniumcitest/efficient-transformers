name: Internal Review Summary

on:
  workflow_dispatch:
    inputs:
      pr_number:
        description: "Original PR number"
        required: true
        type: string
      orig_repo:
        description: "Original repo (owner/repo)"
        required: true
        type: string
      orig_sha:
        description: "Original head SHA"
        required: true
        type: string

jobs:
  summarize-internal-review:
    runs-on: [self-hosted, Linux, X64, internal]

    steps:
      - name: ðŸ“¥ Input parameters (PR / repo / SHA)
        id: show-inputs
        run: |
          echo "PR number : ${{ inputs.pr_number }}"
          echo "Repo      : ${{ inputs.orig_repo }}"
          echo "Head SHA  : ${{ inputs.orig_sha }}"

      - name: ðŸ“‚ Locate internal-review JSON on NFS
        id: locate-json
        run: |
          set -euo pipefail
          NFS_BASE="/prj/bdcqranium/qranium-ci/qeff-comments"
          JSON_PATH="${NFS_BASE}/pr-${{ inputs.pr_number }}.json"

          echo "Expected JSON path: ${JSON_PATH}"

          if [ ! -f "${JSON_PATH}" ]; then
            echo "ERROR: JSON file not found at ${JSON_PATH}"
            exit 1
          fi

          echo "json_path=${JSON_PATH}" >> "$GITHUB_OUTPUT"

      - name: ðŸ‘€ Raw JSON preview (first 400 chars)
        id: preview-json
        run: |
          set -euo pipefail
          JSON_PATH="${{ steps.locate-json.outputs.json_path }}"
          echo "Reading JSON from: ${JSON_PATH}"
          echo "----- JSON preview (first 400 chars) -----"
          head -c 400 "${JSON_PATH}" || true
          echo
          echo "------------------------------------------"

      - name: ðŸ“Š Analyze review (summary, files, critical_issues)
        id: analyze-review
        run: |
          set -euo pipefail

          JSON_PATH="${{ steps.locate-json.outputs.json_path }}"

          echo "===== Parsed Summary ====="
          HIGHEST_SEV=$(jq -r '.summary.highest_severity // "None"' "${JSON_PATH}")
          TOTAL_FILES=$(jq -r '.summary.total_files // 0' "${JSON_PATH}")
          TOTAL_ISSUES=$(jq -r '.summary.total_issues // 0' "${JSON_PATH}")

          echo "  total_files     = ${TOTAL_FILES}"
          echo "  total_issues    = ${TOTAL_ISSUES}"
          echo "  highestSeverity = ${HIGHEST_SEV}"
          echo

          echo "===== Files (Critical/High only) ====="
          echo ""
          echo "| File Path | Lines Changed | Issues Found | Highest Severity |"
          echo "|-----------|---------------|--------------|------------------|"

          jq -r '
            .files[]? |
            [
              .file_path // "",
              .lines_changed // "",
              .issues_found // "",
              .highest_severity // ""
            ]
            | @tsv
          ' "${JSON_PATH}" | while IFS=$'\t' read -r path lines issues sev; do
            clean_path="${path#\`}"
            clean_path="${clean_path%\`}"
            echo "| ${clean_path} | ${lines} | ${issues} | ${sev} |"
          done

          echo ""
          echo "===== Critical issues (all) ====="
          echo ""

          jq -r '
            .critical_issues[]? |
            "- [" + (.severity // "") + "] " + (.one_line // "") 
          ' "${JSON_PATH}" || true

          echo ""
          echo "===== Decision ====="

          case "${HIGHEST_SEV}" in
            Critical|High)
              echo "Overall severity is ${HIGHEST_SEV} -> marking job as FAILED."
              echo "worst_severity=${HIGHEST_SEV}" >> "$GITHUB_OUTPUT"
              exit 1
              ;;
            Medium|Low|None|"")
              echo "Overall severity is ${HIGHEST_SEV} -> marking job as PASSED."
              echo "worst_severity=${HIGHEST_SEV}" >> "$GITHUB_OUTPUT"
              ;;
            *)
              echo "Unknown severity '${HIGHEST_SEV}' -> treating as PASSED."
              echo "worst_severity=${HIGHEST_SEV}" >> "$GITHUB_OUTPUT"
              ;;
          esac
